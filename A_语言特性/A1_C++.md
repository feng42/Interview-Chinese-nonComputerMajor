<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
**Table of Contents**

* [C/C++语言特性](#C/C++语言特性)
	* [1 类与对象](#1-类与对象)
	* [2 关键字](#2-关键字)
	* [3 多态与虚函数](#3-多态与虚函数)
		* [1 C++实现多态](#1-C++实现多态)
		* [2 虚函数的作用](#2-虚函数的作用)
		* [3 动态绑定](#3-动态绑定)
		* [4 静态多态和动态多态](#4-静态多态和动态多态)
		* [5 虚函数表](#5-虚函数表)
		* [6 纯虚函数与析构函数、构造函数](#6-纯虚函数与析构函数、构造函数)
	* [4 内存模型](#4-内存模型)
		* [1 内存分配](#1-内存分配)
		* [2 内存管理](#2-内存管理)
	* [5 指针、数组与引用](#5-指针、数组与引用)
		* [1 指针](#1-指针)
		* [2 智能指针](#2-智能指针)
  

<!-- markdown-toc end -->

# C/C++语言特性
参考书籍：《C++ primer》，《effective C++》，《STL源码解析》，《深度搜索C++对象模型》

## 1 类与对象
类:  定义对象包括什么，以及执行哪些操作
对象:根据类创建

访问       public   protected	private
同一个类   yes	    yes	        yes
派生类     yes	    yes	        no
外部的类   yes	    no          no

多继承:
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};

重载: 同一作用域内，声明几个功能类似的不同函数，形式参数必须不同;可用关键字operator实现运算符重载


## 2 关键字
1. extern
(0) 声明变量或函数为外部链接，该变量或函数名在其他文件中可见
(1) 被修饰的变量(外部变量)是静态分布空间的
(2) 声明的变量/函数应该在别的文件或同文件其他地方定义(实现)
in cpp1:
	double warming //wraming denied
in cpp2:
	extern double warming //use warming from another file
可使用外部变量在多文件程序的不同部分共享数据

More:
http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html

2. static
静态/隐藏在类里
使用：
(1) 修饰变量:静态局部变量，只初始化一次;程序运行后才释放
(2) 修饰全局变量:只能在本文件中访问，extern声明也不行
(3) 修饰函数:只能在本文件中调用;
(4) 不想被释放
(5) 安全性
静态全局变量特点:
(1) 在全局数据区分配内存
(2) 未经初始化的静态全局变量会被自动初始化为0
(3) 整个文件可见，文件外部不可见(不加静态的局部变量是有外部链接性，extern)
静态局部变量特点：
(1) 全局数据区分配内存;作用域为局部作用域(函数或者语句块结束时作用域结束)
(2) 静态局部变量声明时首次初始化，以后不再初始化;没有初始化，程序自动初始化为0
静态类:
(1) 不能通过类名来调用类的非经泰成员函数
(2) 类的对象可以使用静态成员函数和非静态成员函数
(3) 静态成员函数不能引用非静态成员
(4) 非静态成员可以调用静态成员函数，反之不行
(5) 类的静态成员变量必须先初始化再使用

3. const
常量;修饰对象不能改变
- 修饰变量，说明该变量不可以被改变；
- 修饰指针，分为指向常量的指针和指针常量；
- 常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；
- 修饰成员函数，不能改变外面声明的变量，也不能调用非const函数。

4. auto
C++11中，auto用于自动类型推断

5. volatile
表明程序没有修改内存单元，值也可能发生变化（如硬件引起）
例如，程序多次使用变量值，编译器不查找而是将值缓存到寄存器中。volatile将防止这种优化。e.g. 硬件数据读取

6. friend
友元函数:定义在类外部，但有权访问private和protected成员



7. 类型转换
C++四种类型转换：static_cast, dynamic_cast, const_cast, reinterpret_cast

## 3 多态和虚函数表
### 1 C++实现多态
- 多态性：一个接口，多种方法程序运行时决定调用函数
- 多态与非多态区别：早绑定(编译前确定调用地址)还是晚绑定（运行时确定调用）
- 多态的目的：接口重用，找到适应各自对象的实现方法
- C++多态： 调用成员函数时，根据对象的类型之行不同的函数

### 2 虚函数的作用
虚函数: 基类中使用关键字virtual声明的函数，会告诉编译器不要静态链接到该函数
- 虚函数用于实现多态，虚函数在设计上还具有封装和抽象的作用。
- 虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(override)，或者称为重写。重写虚函数体现了C++多态性。
重载则允许有多个同名函数。编译器生成预处理函数，实现同名函数调用时的重载问题。

具体实现见<./A1_cSample/polyArea.cpp>

### 3 动态绑定
对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。

### 4 静态多态和动态多态
静态多态:通过模板技术或者函数重载技术实现的多态，其在编译器确定行为(即程序执行前就准备好了)。
动态多态:是指通过虚函数技术实现在运行期动态绑定的技术。

### 5 虚函数表
虚函数表是针对类的还是针对对象的？同一个类的两个对象的虚函数表是怎么维护的？
编译器为每一个类维护一个虚函数表，每个对象的首地址保存着该虚函数表的指针，同一个类的不同对象实际上指向同一张虚函数表。

### 6 纯虚函数与析构函数、构造函数
纯虚函数声明:
virtual void function1() =0;
虚函数声明：
virtual ReturnType FunctionName(Parameter)

析构函数应当是虚函数，将调用相应对象类型的析构函数
s.t. 指针指向子类对象，调用子类的析构函数，然后自动调用基类的析构函数

## 4 内存 
### 1 内存分配
1. new/malloc
- malloc和free是库函数，而new和delete是C++操作符；
- new自己计算需要的空间大小，比如’int * a = new，malloc需要指定大小，例如’int * a = malloc(sizeof(int))’；
- new在动态分配内存的时候可以初始化对象，调用其构造函数，delete在释放内存时调用对象的析构函数。而malloc只分配一段给定大小的内存，并返回该内存首地址指针，如果失败，返回NULL。
- new是C++操作符，是关键字，而operate new是C++库函数
- opeartor new /operator delete可以重载，而malloc不行
- new可以调用malloc来实现，但是malloc不能调用new来实现
- 对于数据C++定义new[]专门进行动态数组分配，用delete[]进行销毁。new[]会一次分配内存，然后多次调用构造函数；delete[]会先多次调用析构函数，然后一次性释放。
	int char* pa = new char[100];
	int char* pb = malloc(sizeof(char)*100);
- malloc能够直观地重新分配内存,在堆上建立工作区

More:
https://blog.csdn.net/shanghairuoxiao/article/details/70337890

### 2 内存管理
内存对齐的原则
内联函数有什么优点？内联函数与宏定义的区别？
C++内存管理

STL里的内存池实现
STL里set和map是基于什么实现的。红黑树的特点？
STL里的其他数据结构和算法实现也要清楚 
这个问题，把STL源码剖析好好看看，不仅面试不慌，自己对STL的使用也会上升一个层次。
必须在构造函数初始化式里进行初始化的数据成员有哪些
模板特化
定位内存泄露 
(1)在windows平台下通过CRT中的库函数进行检测； 
(2)在可能泄漏的调用前后生成块的快照，比较前后的状态，定位泄漏的位置 
(3)Linux下通过工具valgrind检测
手写strcpy，memcpy，strcat，strcmp等函数
 



## 5 指针、数组与引用

### 1 指针
指针和引用的区别
指针与数组千丝万缕的联系


## 2 智能指针
1. 智能指针是怎么实现的？什么时候改变引用计数？
构造函数中计数初始化为1；
拷贝构造函数中计数值加1；
赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
析构函数中引用计数减一；
在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。

2. share_ptr 与 weak_ptr





