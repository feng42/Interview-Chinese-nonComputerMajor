<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
**Table of Contents**

* [Linux](#Linux)
	* [1 进程与线程](#1-进程与线程)
		* [1 进程与线程区别](#1-进程与线程区别)
		* [2 线程比进程具有哪些优势](#2-线程比进程具有哪些优势)
		* [3 什么时候用多进程/多线程](#3-什么时候用多进程/多线程)
		* [4 LINUX中进程和线程使用的几个函数](#4-LINUX中进程和线程使用的几个函数)
		* [5 线程同步](#5-线程同步)
	* [2 进程间通讯方式](#2-进程间通讯方式)
		* [1 匿名管道与命名管道的区别](#1-匿名管道与命名管道的区别)
		* [2 共享文件映射mmap](#2-共享文件映射mmap)
		* [3 常见的信号有哪些](#3-常见的信号有哪些)
	* [3 内存管理](#3-内存管理)
		* [1 虚拟内存的作用](#1-虚拟内存的作用)
		* [2 虚拟内存的实现](#2-虚拟内存的实现)
		* [3 操作系统层面对内存的管理](#3-操作系统层面对内存的管理)
		* [4 内存池的作用与STL实现](#4-内存池的作用与STL实现)
		* [5 进程空间和内核空间对内存的管理不同](#5-进程空间和内核空间对内存的管理不同)
		* [6 Linux的slab层，VAM](#6-Linux的slab层，VAM)
		* [7 伙伴算法](#7-伙伴算法)
		* [8 高端内存](#8-高端内存)
	* [4 进程调度](#4-进程调度)
		* [1 实时进程和非实时进程](#1-实时进程和非实时进程)
		* [2 静态优先级和动态优先级，优先级的范围](#2-静态优先级和动态优先级，优先级的范围)
		* [3 调度策略](#3-调度策略)
		* [4 交互进程通过平均睡眠时间而被奖励](#4-交互进程通过平均睡眠时间而被奖励)
	* [5 死锁](#5-死锁)
		* [1 死锁产生的条件](#1-死锁产生的条件)
		* [2 死锁的避免](#2-死锁的避免)
	* [6 命令行](#6-命令行)
		* [1 倒序打印](#1-倒序打印)
		* [2 与CPU，内存，磁盘相关的命令](#2-与CPU，内存，磁盘相关的命令)
		* [3 网络相关的命令](#3-网络相关的命令)
		* [4 格式化修改，统计，和正则查找](#4-格式化修改，统计，和正则查找)
		* [5 ipcs和ipcrm命令](#5-ipcs和ipcrm命令)
		* [6 查找c结尾的文件](#6-查找c结尾的文件)
		* [7 创建定时任务](#7-创建定时任务)
	* [7 IO模型](#7-IO模型)
		* [1 五种IO模型](#1-五种IO模型)
		* [2 select，poll，epoll的区别](#2-select，poll，epoll的区别)
* [Linux的API](#Linux的API)
* [设计模式](#设计模式)
* [分布式系统](#分布式系统)
* [其他](#其他)

<!-- markdown-toc end -->


# Linux
主要参考书籍：《现代操作系统》，《APUE》，《UNP》，《LINUX内核设计与实现》，《深入理解LINUX内核》

## 进程与线程
### 1 进程与线程区别？ 
1. 进程是资源分配的基本单位，线程是cpu调度，或者说是程序执行的最小单位。但是并不是说CPU不在以进程为单位进行调度，虽然在某些操作系统中是这样。同一个进程中并行运行多个线程，就是对在同一台计算机上运行多个进程的模拟。
2. 进程有独立的地址空间，而同一进程中的线程共享该进程的地址空间。比如在linux下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的寄存器和堆栈（线程栈），比如在windows中用_beginthreadex创建一个新进程就会在调用CreateThread的同时申请一个专属于线程的数据块（_tiddata)。虽然，线程有自己线程栈，线程可以直接访问全局变量，甚至可以访问进程地址空间中的每一个内存，所以一个线程可以读写甚至清楚另一个线程的堆栈。
3. 线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量，打开的文件，子进程），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。在一个线程中分配的堆在各个线程中均可以使用，在一个线程中打开的文件各个线程均可用，当然指同一进程中的线程。
4. 多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。
5. 线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。
6. linux中进程具有父子关系，形成进程树，但是线程是平等的没有父子关系

### 2 线程比进程具有哪些优势？ 
- 多进程程序，一个进程崩溃不会影响其他进程，但是进程之间的切换和通信代价较大；
- 多线程程序，一个线程崩溃会导致整个进程死掉，其他线程也不能正常工作，但是线程之前数据共享和通信更加方便。
    进程需要开辟独立的地址空间，多进程对资源的消耗很大，而线程则是“轻量级进程”，对资源的消耗更小，对于大并发的情况，只有线程加上IO复用技术才能适应。


### 3 什么时候用多进程/多线程？
  对于需要频繁交互数据的，频繁的对同一个对象进行不同的处理，选择多线程合适，对于一些并发编程，不需要很多数据交互的采用多进程。
### 4 LINUX中进程和线程使用的几个函数？ 
1.  调用系统的API，windows下是CreateThread，_beginThread（不要用），_beginThreadex（推荐使用），Linux使用POSIX线程

2.  使用第三方库的多线程函数，比如Boost库，实现用户级线程，MFC库中的afxBeginThread实际是调用系统API

3.  使用C/C++库里的函数，包含头文件中，thread函数创建线程（用户级线程）

### 5 线程同步？ 
- 在Windows下线程同步的方式有：互斥量，信号量，事件，关键代码段 
- 在Linux下线程同步的方式有：互斥锁，自旋锁，读写锁，屏障(并发完成同一项任务时，屏障的作用特别好使) 知道这些锁之间的区别，使用场景？

## 进程间通讯方式
### 1 匿名管道与命名管道的区别
    匿名管道只能在具有公共祖先的两个进程间使用。
### 2 共享文件映射mmap 
    mmap建立进程空间到文件的映射，在建立的时候并不直接将文件拷贝到物理内存，同样采用缺页终端。mmap映射一个具体的文件可以实现任意进程间共享内存，映射一个匿名文件，可以实现父子进程间共享内存。
### 3 常见的信号有哪些？
    SIGINT，SIGKILL(不能被捕获)，SIGTERM(可以被捕获)，SIGSEGV，SIGCHLD，SIGALRM

## 内存管理
### 1 虚拟内存的作用？
### 2 虚拟内存的实现？
### 3 操作系统层面对内存的管理？
### 4 内存池的作用与STL实现
### 5 进程空间和内核空间对内存的管理不同？
### 6 Linux的slab层，VAM？
### 7 伙伴算法
### 8 高端内存

## 进程调度
### 1 Linux进程分为两种，实时进程和非实时进程；
### 2 优先级分为静态优先级和动态优先级，优先级的范围；
### 3 调度策略
### 4 交互进程通过平均睡眠时间而被奖励；

## 死锁
### 1 死锁产生的条件； 
### 2 死锁的避免；

## 命令行
### 1 Linux命令 在一个文件中，倒序打印第二行前100个大写字母
cat filename | head -n 2 | tail -n 1 | grep '[[:upper:]]' -o | tr -d '\n'| cut -c 1-100 | rev 
### 2 与CPU，内存，磁盘相关的命令(top，free, df, fdisk)
### 3 网络相关的命令netstat，tcpdump等
### 4 sed, awk, grep三个超强大的命名，分别用与格式化修改，统计，和正则查找
### 5 ipcs和ipcrm命令
### 6 查找当前目录以及字母下以.c结尾的文件，且文件中包含”hello world”的文件的路径
### 7 创建定时任务

## IO模型
### 1 五种IO模型：阻塞IO，非阻塞IO，IO复用，信号驱动式IO，异步IO
### 2 select，poll，epoll的区别
线程池，内存池 自己动手实现一遍


# Linux的API
## fork与vfork区别 
fork和vfork都用于创建子进程。但是vfork创建子进程后，父进程阻塞，直到子进程调用exit()或者excle()。 
对于内核中过程fork通过调用clone函数，然后clone函数调用do_fork()。do_fork()中调用copy_process()函数先复制task_struct结构体，然后复制其他关于内存，文件，寄存器等信息。fork采用写时拷贝技术，因此子进程和父进程的页表指向相同的页框。但是vfork不需要拷贝页表，因为父进程会一直阻塞，直接使用父进程页表。

## exit()与_exit()区别 
exit()清理后进入内核，_exit()直接陷入内核。

## 孤儿进程与僵死进程
### 1 孤儿进程是怎么产生的？
### 2 僵死进程是怎么产生的？
### 3 僵死进程的危害？
### 4 如何避免僵死进程的产生？

## Linux是如何避免内存碎片的
### 1 伙伴算法，用于管理物理内存，避免内存碎片;
### 2 高速缓存Slab层用于管理内核分配内存，避免碎片。

## 共享内存的实现原理？

## 系统调用与库函数(open, close, create, lseek, write, read)

## 同步方法有哪些？
### 1 互斥锁，自旋锁，信号量，读写锁，屏障
### 2 互斥锁与自旋锁的区别：
    互斥锁得不到资源的时候阻塞，不占用cpu资源。自旋锁得不到资源的时候，不停的查询，而然占用cpu资源。
### 3 死锁


# 其他
### 1 ++i是否是原子操作 
    明显不是，++i主要有三个步骤，把数据从内存放在寄存器上，在寄存器上进行自增，把数据从寄存器拷贝会内存，每个步骤都可能被中断。
### 2 判断大小端


# 设计模式
## 单例模式线程安全的写法
## STL里的迭代器模式，适配器模式


# 分布式系统
## map_reduce原理 （这篇文章讲的很通俗易懂）
## 负载均衡
## CDN
