<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-generate-toc again -->
**Table of Contents**

* [网络与TCP/IP](#C/C++语言特性)
	* [1 TCP与UDP之间的区别](#1-TCP与UDP之间的区别)
		* [1 IP首部，TCP首部，UDP首部](#1-IP首部，TCP首部，UDP首部)
		* [2 TCP和UDP区别](#2-TCP和UDP区别)
		* [3 TCP和UDP应用场景 ](#3-TCP和UDP应用场景 )
		* [4 如何实现可靠的UDP](#4-如何实现可靠的UDP)
	* [2 TCP三次握手与四次挥手](#2-TCP三次握手与四次挥手)
	* [3 TCP相关技术](#3-TCP相关技术)
	* [4 客户与服务器模型](#4-客户与服务器模型)
	* [5 域名解析过程](#5-域名解析过程)
* [HTTP](#HTTP)
	* [1 http/https 1.0、1.1、2.0的特点和区别](#1-http/https 1.0、1.1、2.0的特点和区别)
	* [2 https与http的区别？如何实现加密传输？加解密方式？](#2-https与http的区别？如何实现加密传输？加解密方式？)
* [安全相关](#安全相关)
	* [1 SQL注入](#1-SQL注入)
	* [2 XSS](#2-XSS)
	* [3 CSRF](#3-CSRF)
	* [4 SYN洪水攻击](#4-SYN洪水攻击)
	* [5 APR欺骗](#5-APR欺骗)

<!-- markdown-toc end -->

# 网络与TCP/IP
参考书籍：《图解TCP/IP》，《TCP/IP详解 卷一》，《图解HTTP》，《HTTP权威指南》

## TCP与UDP之间的区别 
- TCP概述： TCP 协议是面向有连接的协议，还有数据重传、流量控制等功能，TCP 协议能够正确处理丢包问题，保证接收方能够收到数据，与此同时还能够有效利用网络带宽。然而 TCP 协议中定义了很多复杂的规范，因此效率不如 UDP 协议，不适合实时的视频和音频传输。
- UDP概述： UDP 协议是面向无连接的协议，它只会把数据传递给接收端，但是不会关注接收端是否真的收到了数据。但是这种特性反而适合多播，实时的视频和音频传输。因为个别数据包的丢失并不会影响视频和音频的整体效果。


### 1 IP首部，TCP首部，UDP首部 
1. IP首部
- A类IP地址 
    A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个。

    A类地址中以127开头的为保留地址，计算机本机地址是127.0.0.1

- B类IP地址 
    B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。

- C类IP地址 
    C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。

- D类IP地址 
    D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。 

[./_asset/IPAddress.png]

- 子网掩码
    子网掩码长度也是32位，由一段连续的1和一段连续的0组成。1的长度就表示网络标识的长度。以IP地址172.20.100.52为例，它本来是一个B类IP地址(前16位是网络标识)，但通过子网掩码，它可以是前26为为网络标识的IP地址。也就是说子网掩码的作用是扩大了原有IP地址的网络标识： 

[./_asset/SubnetMask.png]

2. TCP首部
- 源端口号：发送端端口号
- 目标端口号：接受端端口号
- 序列号：发送数据时，表示发送数据的位置，发送完一次数据后，序列号的值都等于原来的序列号加上数据的长度
- 应答号：用于接受端告诉发送端下次应该从哪个位置开始发送，表示前面的数据已经都收到了
- 数据偏移：实际就是TCP首部长度
- 保留：一般设置为0，用于后续扩展
- 控制位：长度为8，从左到右分别是CWR，ECE，URG，ACK，PSH，RST，SYN，FIN
- 窗口大小：能够发送数据的最大值，为0时可以发送探测窗口
- 校验和：与UDP校验和作用相同
- 紧急指针：用于处理紧急情况
- 选项：其他控制设置

[./_asset/TCPHead.png]

3. UDP首部
- 源端口号：表示发送端端口号，不需要时设为0
- 目标端口号：表示接收端端口号
- 包长度：表示整个UDP包的长度
- 校验和：为了提供可靠的UDP首部和数据而设计，只要源IP地址，目标IP地址，源端口号，目标端口号，协议号有一个发生了篡改校验和都会不正确。


### 2 TCP和UDP区别 
1. TCP基于有连接，UDP基于无连接。有连接就是TCP在传输前先发送连接请求和应答包，确定双方能够正常传输后，才开始进行数据传输。无连接就是UDP在发送数据之前，并不考虑对方能否接受到，甚至目的地址可能都是无效；
2. TCP能保证可靠传输，UDP不能保证可靠传输TCP。所谓可靠就是TCP能保证把数据一定送到目的地址。为了实现可靠，TCP采用有连接的，超时重传，应答机制等。而UDP则没有这些，也不能保证数据一定能送到；
3. TCP结构复杂，消耗资源多，建立过程较慢较复杂。UDP结构简单，消耗资源少，建立过程较快；
4. TCP基于流模式，UDP是数据报模式。TCP把数据看成一连串无结构的字节流，没有边界，一段段传输构成了整个数据块。通过发送缓冲区和接受缓冲区来存储数据流。而UDP数据报模式，每一个数据报都是一个独立的对象，有着指定的大小。
5. TCP连接只能是点到点，而UDP可以一对一，一对多或者多对多。TCP只能是点到点原因很简单，因为TCP的传输前要先建立连接。因此，广播和多播只能采用UDP数据报的方式。
6. TCP有确认，重传，拥赛控制机制，UDP在没有建立连接或者对方已经退出的情况下任然会继续发送数据，导致通信流量的浪费。


### 3 TCP和UDP应用场景 
- TCP:用于实现可靠传输的情况，文件非常重要，对网络拥堵有较高要求的情况。
- UDP:
1. 用于高速传输和实时性较高的场合（即时通信）。对于采用UDP的实事视频通信，如果出现丢包也只会出现短暂卡顿，但是如果采用TCP丢包后需要重发，会导致很长时间的卡顿。 
2. 包总量较少的通信（DNS），客户端较多 
3. 广播通信

### 4 如何实现可靠的UDP

## TCP三次握手与四次挥手
详细说明TCP状态迁移过程
[./_assets/TCPConnectAndDisconnect.jpeg]

1. 三次握手和四次挥手状态变化
- 三次挥手:
(1) 客户端发送请求包，告诉服务器：“我想和你通信？”数据包中SYN位置为1，假设其序列号为x，客户端状态变成SYN_SENT；
(2) 服务器端接受到请求包后也发送一个请求包，告诉客户端：“现在可以建立连接”。数据包中SYN位置位1，假设其序列号为y，注意客户端序列号和服务器端序列号并没有关系，他们是由各自的内核按照一定的规则生成的。但是这个应答包的32位应答号，必须是x+1，之所以加1是因为客户端发过来的包SYN位被认为占一个数据。因此，告诉下一包从x+1开始发。发送后，服务器从监听状态变成SYN_RCVD状态。
(3) 客户端发送应答数据包，告诉服务器：“那我们开始发送数据吧”。数据包应答号为y+1。客户端变成ESTABLISHED状态，即可以传输状态。服务器端接受到应答数据包后，变成ESTABLISHED状态。

- 四次挥手：
(1) 客户端发送请求断开的数据包，告诉服务器：“数据传完了，我要断开了”。发送一个FIN包，序列号x+2。客户端转移到FIN_WAIT_1状态。
(2) 服务器端发送应答包，告诉客户端：“行，我知道了，你断开吧！”。应答号为x+3，服务器进入CLOSE_WAIT状态。客户端收到应答后，转移到FIN_WAIT_2状态。
(3) 服务器发送一个断开数据包，告诉客户端：“既然传完了，那我这边的开关也准备关了”。序列号为y+1，发送完后服务器进入LAST_ACK状态。
(4) 客户端发送一个应答包，告诉服务器：“好的，我知道你要断开了。”应答号为y+2。客户端进入TIME_WAIT状态。 

2. 2MSL是什么状态？作用是什么？
TIME_WAIT又称为2MSL等待状态，MSL是系统中定义的最大报文生存时间，任何TCP报文在网络中生存时间超过这个值就必须被丢弃。 
等待MSL的原因是防止最后一个ACK丢失后可以进行重发，如果ACK丢失后，服务器会重发FIN。
 
3. 三次握手为什么不是两次或者四次？
- 为什么是3次?
    可能你会认为第3次好像是多余的。是因为信道是不可靠的，可能存在延时或者丢包，而三次是满足可靠传输的最小次数。
    举例说明：如果只有两次，假设主机A发送的第一个请求包延时，主机A在等待一段时间后重新发送一个请求包，完成数据连接并断开。但是这个时候上次的发的请求包才到达主机B，这时主机B认为是又一次连接，因此发送一个请求包给A，但是Ａ并没有发送新的请求因此会丢失该数据包。最后，B就一直等待A发送数据，浪费了资源。
    除此之外，我个人认为3次握手更加安全，加大了攻击的难度。如果只有两次，一个发送一个应答，那么攻击着可以采用IP欺骗，发动SYN洪水攻击，并且服务端还都是ESTABLISHED状态。如何防御？难度更大了。对于三次握手的可以限制半连接的数量来达到一个防御的作用。

- 为什么是4次？
    TCP通信是一种全双工的通信，可以进行半关闭（与半打开区别：半打开是连接后的客户端和服务端有一端异常关闭了），所谓半关闭是指可以只关闭从A到B的方向，而B到A的方向还可以继续传输。因此，在客户端和服务器端分别进行关闭。


## TCP相关技术
1. TCP重发机制
(1) 超时重传(RTO)
    当一个包被发送后，就开启一个定时器，如果定时时间到了，还未收到能确认该发送包的应答包，就重传一份数据。注意收到的应答包可能是该包也可能是后面包的，但是只要能确认该包被收到就行。另外如果，是因为网络延时造成重传，则接受端收到重复数据包后丢弃该包。 
(2) 快速重传
    当如果发送端收到一个包的三次应答包后，立即重传，比超时重传更高效。
[./_assets/FastRetransmission.jpeg]
（Nalge算法）

2. TCP的拥塞控制使用的算法和具体过程
判定拥塞出现的条件：网络中出现分组丢失（发生超时或收到重复确认）
拥塞避免算法中用到了<慢启动>，<快速重传>，<快速恢复>。 
拥塞避免算法需要维持两个变量：M拥塞窗口>和<慢启动阀值>。
- 慢启动算法:设置初始拥塞窗口大小为1，以后每收到一个应答拥塞窗口大小就加1（图中指定一个窗口大小是1000个字节），窗口大小呈指数级增长。客户端可发送数据的取拥塞窗口和应答包窗口两者中较小的那个。 
[./_assets/SlowStart.jpeg]
- 拥塞控制算法:
拥塞控制算法先采用慢启动算法，到达慢启动阀值后采用拥塞避免算法。
(1) 通信开始时，发送方的拥塞窗口大小为 1。每收到一个 ACK 确认后，拥塞窗口大小加1。
(2) 由于指数级增长非常快，很快地，就会出现确认包超时，认为发生了拥塞。
(3) 此时设置一个“慢启动阈值”，它的值是当前拥塞窗口大小的一半。
(4) 拥堵发生后将拥塞窗口大小设置为 1，重新进入慢启动过程。
(5) 由于现在“慢启动阈值”已经存在，当拥塞窗口大小达到阈值后，停止使用慢启动算法，开始采用拥塞避免算法。窗口大小开始线性增加。
(6) 随着窗口大小不断增加，如果收到三次重复确认应答，则进入“快速重发”阶段。对于这用拥塞情况，TCP 将“慢启动阈值”设置为当前拥塞窗口大小的一半，再将拥塞窗口大小设置成阈值大小（也有说加 3）。然后采用拥塞避免算法增加窗口大小。
(7) 随着窗口大小不断增加，如果发生超时。对于这种拥塞情况，TCP将满启动阀值设置为当前拥塞窗口的一半，然后将拥塞窗口设置为1。
窗口变化图：
[./_assets/CongestionWindow.jpeg]

3. TCP的窗口滑动
[./_assets/WindowSlide.jpeg]
- 窗口合拢：由左端边缘向右靠近，称为窗口合拢，在接受到数据后发生。 
- 窗口张开：右右端向右移动，称为窗口打开，在处理完数据后发生。

    如果接收端发送的应答包中窗口大小为0，则客户端会等待一段时间后发送探测包，重新确认窗口的大小。接受端如果处理完了数据也会重新发送应答包，通知发送端。反正死锁的发生。
    引入窗口后，TCP的应答包如果部分丢失，无需重传，由后面的应答包保证。TCP为了提高效率，采用延时再确认应答，和选择性确认应答，即收到数据包后不立即发送应答包，而是等待收到下一个或多个包后发一个应答。


## 客户与服务器模型
TCP客户与服务器模型，用到哪些函数
UDP客户与服务器模型，用到哪些函数

## 域名解析过程
 ARP的机制，RARP的实现 Ping和TraceRoute实现原理

# HTTP
<awesome-http>
## http/https 1.0、1.1、2.0的特点和区别
get/post 区别
HTTP返回状态码
http 协议头相关
http数据由请求行，首部字段，空行，报文主体四个部分组成 
首部字段分为：通用首部字段，请求首部字段，响应首部字段，实体首部字段

## https与http的区别？如何实现加密传输？加解密方式？
浏览器中输入一个URL发生什么，用到哪些协议？


# 安全相关


## SQL注入
## XSS
## CSRF
## SYN洪水攻击
## APR欺骗
