
**2
关键问题是，建立一个空表头，否则在初次计算时问题很多
tmp=ListNode(0)
res=tmp
题目最后
res=tmp.next
del tmp

**3
创建一个list用来记录最长子串长度，一个str用来记录‘当前’无重复字符串，用于对比
遍历输入字符串s：
如果s[i]不存在于str中，加入str末尾
如果s[i]在str中，遍历str：找到相同字的位置，取这一位后面的str为新的str
对i，记录当前时刻str长度到list中
遍历字符串s后，取list中最大值即为结果

**5
本题用了一个s[][::-1]来表示字符串的倒序读取，从而可以比较是不是回文数字（因为一个回文数字去掉左右两端仍是回文数字）
用了两个if来辨别abba和aba的情况（即越过回文字中间点）

**11
贪心法，左右两边向内压缩

**14
选第一个的字符长度，在每个字符串找是否有这个前缀字母，没有返回，注意字符串序列

**15
新建二维vector，记录找的结果。利用vector自带的sort排序
通过两轮遍历找出满足条件的三元数组。
1）如果flag数为正，序列中后面的都是正数，不用再找
2）如果flag=flag+1,跳过相同
3）设计target=0-flag，对flag后面的数进行前后夹

**17
将长字符串的组合转换成str[0]与str[1:]的组合拼接
先搜索str[1:]直至编程单字符->此时达到字典key
分次组合并添加到list中进行返回

**22
这个题的自带输入变量只带一个正数，而我们需要对左右括号分别计数，因此需要新建一个函数，输入传入两个数
用l和r计数左右括号数量，那么当l和r都为零的时候，就生成了一个括号组合，可以将这个组合加入结果列表
通过l和r的对比进行判断：
1)一定先有左括号，所以先判断左括号值
2）因为每个右括号之前都要放一个左括号，r=l只能放左括号，r>l可以放右括号，禁止在r小于l的情况下放括号

**23
排除空列表或者列表中的空链
对当前list求最小值，将最小值放到链表末端
设链表总长度为N，时间复杂度为N*k
(不够快）

**29
判断是否溢出（-2^31/(-1)）
判断商的正负号，不要用乘(sign)返回结果，用if
比较被除数m与除数n和除数n移位的结果，计数返回商

**33
还是得先找到增大的起点
然后二分法

**34
logN的时间复杂度，那就肯定是二分法了
（测试样例可能并不比两边向内缩更快）

**36
建立两个数组记录在第i行/第j列/第k宫中当前数字是否出现过，如果没出现，现在出现合理，如果已出现，说明数独无效

**38
迭代读数，如果数字连续，那么存到不连续时读出来

**41
如果数组中最大数小于1或者最小数大于1,那么数组第0位无论如何不会是1,返回1,正确
对数组进行操作，将每个数移动到应该存在的位置，第i个数：i->(nums[i]-1)，负数和和超过范围的数不移位，因为他们肯定占了别的位置，如果没被替走，就是答案

**42
两个指针左右逼近，这样可以解决读到一侧连续下降没有解的问题
同时记录左右的最大柱，从小的一侧向大的一侧找（这样找能保证总能存在湖接雨水）

**43
int()将字符转整形，通过10倍加的方式还原数字
str()将整形转字符，通过字符串拼接再赋值得到答案

**46
对当前链表，取一个作为第一个，剩下的进行全排列，将排列后的结果进行合并
[注意从list里取出要放回！！]
[注意缩进！！]

**48
先转置，再水平翻转(矩阵操作)

**49
库模块collections可以生成多种数据类型
建立26个元素计数元组alphabet来表示字母，如果字母出现一次就在对应元素上加一
具有相同alphabet（即字母出现次数相同的）用同一个keys添加

**50
折半计算，每次都算一个平方根，如果幂次为奇数，再乘一次自身。0次方==1

**53 
分治法很经典，算法导论上也有
动态规划:因为只求最大值而不求最大区间，因此维护一个最大值maxn,顺序算累计值，如果累加值ans小于0则归零

**54
递归，读第一行，读最后一列，翻转矩阵，读剩下的矩阵内容

**55
动态规划：状态为每个点能跳的最大长度，状态转换为这点能跳最大和前一个点能跳的最大

**56
先按区间头进行升序排序
对排序好的区间，将邻接区间进行拼接，如果一个区间不能与比它大的邻接区间拼接，那么更大的也不行，反之亦然

**60
n个数的全排列，任意一个数字i作为排列头的次数是(n-1)!，用k/(n-1)!可以得到头部第一位的数字(下标)
k%(n-1)!得到剩余数字
注意用一个数组记录n!的值，用查表代替运算

**62
[i][j]=[i-1][j]+[i][j-1]

**66
注意检查列表头，因为仅+1,所以头部最多进1位

**69
牛顿二分法

**71
建立一个数组记录路径点，tmp记录当前点
每读到一个"/"，根据tmp判断是加入路径还是删除路径
最后根据路径点返回路径

**73
首先记录首行或者首列是否有零
然后将中间元素的0位置记录到首行首列
接着根据分别根据首行首列修改矩阵内的值
最后根据记录将首行首列选择置零

**75
两次扫描很简单，先扫除0、1、2数量，第二遍重写数组
一次扫描：除了当前遍历位置i，再设计[zero]和[two]两个标记最后一个0和第一个2的位置，如果读到0或2分别取下一个/前一个位置进行交换

**76(?)
定义两个数组，如果原矩阵点为零，那么该行就需要置零，不记录行，而是将对应行真值变零。

**76(?)
先将目标字符串读到哈希表
遍历输入字符串，遇到s，减小未读字符数量；
如果已经都读完，将头指针向后，寻找最小的开头点。
返回原数组的[minStart:minStart+minSize]

**78
不断从nums尾部取走tmp值，对剩余部分计算子集
f([n+1])=f([n])+[f([n])+[n+1]]
不重复->由于有46题的基础，只要pop不放回就能不重复

**79
建立一个同样大的二维list记录字符有没有被读过
判断是否越界/读过/字母相等，如果都对那么读这个字母，visited记录已被读过
开始遍历四个方向直至读完单词长度
记得读完把读过的位置还原为False，否则会影响下一次遍历（导致找不到正确答案）

**93
回溯法，从第一个字符开始检查1、2、3位组成的数能不能构成ip，构成则加入
最终在第4个ip处检查是否超界
起始为为0,仅将0加入字符并停止查找

**94
二叉树遍历并不难，问题是如何返回数组/列表变量：
空值返回[]，非空值返回[val]
注意self的用法

**103
设计一个链表/列表存储即将要遍历的层节点，取得这次要读取的结点数量
利用pop的形式读取列表第一个结点的值
如果该结点有子结点，加入列表末尾
当这一层需要读取的结点全部读完时，下一层待遍历结点已经录入链表了
*注意结点长度/非空的判断，防止多读一层空列表


**105
1）前序的第一个结点是根结点
2）找到根结点在中序序列中的位置，之前为左子数，之后为右子树
3）根据结点位置，在前序中找前x个为左子数，之后为右子树
4）明确左右子树，递归构造

**116
建立一个列表放层结点，一个列表放下一层结点
每层第一个结点为左结点，该结点的left一定是下一层的左结点
对这层剩余结点，建立next指针，删除right指针(注意！不删除会有大量多余指针)，取子结点到下一层列表，直至层列表为空
交换本层列表和下层列表

**121 c++
始终保持最低价买，最高价卖
buy=min(buy,now)
profit=max(profit,now-buy)
(不要再想着递归那个方法了）

** 120
原题自上向下找路径和，那么反过来自下向上找最小路径
对于每一个点(i,j),他的最小值一定是min((i+1,j),(i+1,j+1))+(i,j)
因为下一层总比上一层多1,所以不会越界。(i,j)变为(0,0)时达到最小

**122
审题不细！不是只买一次，可以多次买！
所以寻找最大子数组并不适用，因为股价一下跌就卖了

**124
递归求解，分别求左子树最大/右子树最大/带结点的最大路径
可以设计一个类private变量，private变量在各个子函数里都可读取->所以在每一次计算前需要将private重新初始化
返回的是通过结点的最大路径（左/右/只结点）

**125
分别从头和从尾进行读数，如果是字符则进行比较

**127
与之前的层遍历二叉树类似，建立cur_level与next_level一层层读取结点,将原word建立一个数，深度优先搜索，一旦搜索到就返回
思考：通过c遍历26个字母建立单词，再在字典中查找是否有这个单词，和 将字典中剩余单词与现在读的比对，拿个时间效率高。需要研究python如何实现in

**128
先排序，再找最长序列。时间复杂度=O(排序)+O(n)
用两个dict存储数据，一个表示序列头，一个表示序列头的连续值
每次更新使自己指向序列头，同时让序列头的连续值增加，最后使序列尾指向序列头

**130
将所有能存活的换个负号标记，最后在清扫一遍
递归找连通点
学习了map()函数用法

**138
先从1->2->3->4->NULL转换成1->1'->2->2'->3->3'->4->4'->NULL
再将原点的随机指针赋给复制指针的随机指针，注意这时候原来的随机指针指的是旧指针，应该赋的正确值为p->random->next
最后在链表中删掉原结点，变成1'->2'->3'->4'->NULL

**142
先通过快慢指针找到一个在环中的点，没找到说明不存在环
然后对这个环内点向后查找，直至能回到这个点，找到环长度
重新利用快慢指针，快指针比慢指针快k，找到环的头结点

**146
让一个结点同时具有双向链表与哈希表性质，双向链表使更新达到O(1)，哈希表使更新达到O(1)
写两个类操作，一个对双链表具有更新开头，移除结点和删除结点末尾操作
另一个包含双向链表类，能够进行哈希查找并且进行链表操作

**148
先用快慢指针找到中点，然后递归调用归并算法
归并算法：一链表为空，返回另一个，双链表不空，small.next=merge(small.next,big)

**150
最基本的思路，用一个栈存储数据，如果读到运算符，运算最末尾的两个数

**151
先整体翻转，然后翻转单词
idx表示单词头，不为零需要加空格，翻转单词，更新结尾，最后根据idx剪裁

**155
维护一个值记录最小值，当入栈的值小于这个最小值，那么将这个值压入，再将最小值变为入栈值记录，最后压入入栈值
如果要取出值为最小值，从栈中在取出一个值，该值是取出值入栈前最小值，满足条件

**160
如果两个链表有相交点，那么两个链表是A+C，B+C的构成
如果分别从A、B开始查两个表：
A->C->B->C
B->C->A->C
会在第二次到C的开头时相等
如果没有相交？
长度相等->遍历完各自链表同时变None/NULL，退出循环
长度不等->遍历完对方链表同时变None/NULL，退出循环

**162
折半查找，左=右即找到了

**166
首先对正数部分进行判断，如果能整除直接返回结果
对后面的部分，记录每一个（被除数）最后一次出现时（未进入循环的最后一个商数）的位置
如果产生循环，返回头部+“未进入循环的商数部分+“(”+“循环的商数部分”+“)”
如果余数为零，返回头部+所有商数部分

**169
写个词典
注意单个众数返回的是数值不是列表

**171
使用ord将获得字符大小，容易计算

**172
n!=[5k*5(k-1)*...*5]*a,a为不被5整出的数的乘积。
n!=(5^k)*k!*a,n=5k+r,
所以求n！中5的个数f(n!)=k+f(k!),递归可以求解

**176
[first MySQL query statement]
emmmmmmmmmmmm
distinct: 去重  as:起别名  order by:分类 ASC:升序 DSEC:降序 
LIMIT:结果数量(一个参数，行数;两个参数，偏移量(从0开始)，显示行数）
IFNULL(A,B):不为空返回A，为空返回B

**189
从后面取出k个元素pop()，list.insert()到头部，基础想法
采用列表拼接的方法，可以快速完成任务。注意：这种方法需要检查输入k有效

**200
找到1->标零，每进入几次递归，就找到多少个岛屿
注意输入是"1"str，而不是数字1

**202
如果出现无限循环，那么结果必定在之前出现过，那么就用列表记录计算结果，not in检查

**206
两个指针，一个指向新链表的头，一个指向新链表的尾
一开始时两个指针都指向旧链表的头
将链表尾指向后继的后继，将后继放到链表头

**207 py
建立有向图，和对应结点标记(0==白，1==灰，2==黑)
使用深度优先法找环，产生后向边（对(u,v),visited[v]==1)，说明存在环

**210 c++
和207题类似步骤，这次采用的是后键有向图邻接表
如果用BFS找环，先进行拓扑排序，移除入度为0的点
如果最后仍剩下入度不为0的点，存在环

**215
善用sort()函数！！！
注意排序后是由小到大，所以要读[-k]

**217
用dict

**221 {需要再做}
dp[i][j]表示到达(i, j)位置所能组成的最大正方形的边长
任意一点dp[i][j]，该点是正方形的右下角
dp[i-1][j-1], dp[i][j-1]，和dp[i-1][j],找最小值+1，用dp的值更新res
一维数组可以解决

**227
有数读数
读取乘除法的时候执行的操作依然是加减法，op读取乘除之后下一次读数才会进行运算。
其实不需要栈，一个当前结果就行

**230
1)二叉搜索树左子树结点不大于根结点，右子树结点不小于根结点
2)中序遍历，结点值是递增的，第k个结点刚好为第k小的元素

**236
如果两个结点分属这个结点的左右子树：返回这个根结点
如果一个结点是另一个结点的父结点，那么一定在父节点的左子数或者右子树中，那么对这个结点的左右子树找最小父节点，一定有一个不存在,找到的那个子数里一定是另一个结点

**238
正向阶乘，第i位的值是左侧的值的乘积
反向阶乘，第i位的值是右侧的值的乘积
相乘，gg

**239
对[i:i+k]求最大值，加入ret，遍历所有数据


**240
如果从左上开始搜索右上，那么向下和向右都是增大的
选择从左下（右上）开始搜索，向右（下）是增大，向上（左）是减小，便于搜索

**242
使用了dict对字母进行计数

**287
本题的难点在于空间复杂度O(1)，也不能修改数组本身，否则i与nums[i]位置是最容易的
那么由于已知数值范围在1~n，那就折半查找中间数mid，每次循环招数组中在low到mid之间的数值有多少，如果大于(mid-low+1)，那就在[1,mid]内，如果小于，那就在[mid+1，high]内。
每次循环都要读取所有n个数，时间复杂度o(n)，循环次数是log2(n)，所以总体时间复杂度是O(nlgn)

**289
先对每个元素判断变化情况，0->1=10,1->0=11,通过模的值判断是否变化
再读取一遍矩阵，将标识变化，10->1,11->0
但是这样比较慢

**300
n^2:动态转移，dp[x]=max(dp[x],dp[y]+1)
n*log(n):维护单调序列，遍历nums数组，二分查找数在序列中位置，替换（没太看懂）

**322
和跳格子类似，从基础硬币（基础行列）开始向上构造，直至达到当前面值，因为每一次构造都选择了可能的最小值，所以最终会得到最小值

**328
基本想法：一个链表记奇数，一个链表记偶数，记完之后奇数表末尾指向偶数表开头，删掉空表头
[一遍过的第一个代码]

**329
动态规划+DFS
用同等大小矩阵dp记录当前点开始的最长递增路径
对每个起点进行dfs搜索，如果大于则继续递归调用，更新最大值

**334
设置维护一个二元子数组来判断是否存在
first一定有值，通过first找出顺序最小
如果有比first大的，对second赋值，即为顺序次小
如果还有比second大的，成立
通过sys.maxint得到整形最大值，进行初始化

**347
一边扫描，用字典记录出现频率
利用[sorted]函数进行字典的值的排序

**350
使用list完成，用了list.remove()解决重复问题
<no advanced>

**354
先排序，然后就变成了二维的最长递增子数列问题
学习了使用bisect模块

**371
分别计算非进位和(^)和进位(&,<<)，递归计算，直至有一个加数为零
python下跑不对—1+1,应该是python的变量类型哪里出了问题

**393
大概能明白是用来判断二进制数值否符合范围
再多了不太懂<need twice>

**432
如果想要在O(1)时间内返回最大值和最小值，那么建立一个链表，链表是按照出现次序从大到小排序的，第一个结点代表GetMaxKey()，最后一个结点代表GetMinKey();
每个结点内记录出现的频率值和这个频率值出现的有哪些关键字，其中关键字的记录为了能在O(1)时间内删除，要用哈希表;
为了在O(1)时间内找到key和freq的频率，同样建立哈希表即可
HashMap:key->node
list[node]
node->val,node->HashMap:keys

**454
如果全部遍历，那是O(n^4)的时间复杂度
用dict分别存取AB、CD的和的结果，最后进行相反数判断，时间复杂度O(n^2)

**547
建立数组f存取记录
用并查集的方式找到左右朋友
计算朋友圈数目

**567
通过维护两个字典，记录s1、s2的字符出现次数，比较两个字典来判断是否在s2中出现s1的排列
时间复杂度O(len(s2))

**621
寻找个数最多的任务数量，即可满足任务间隔要求
相同最多任务数->任务对
(最多任务数-1)*(n+1)+(相同最多任务的任务个数)

**674
一个head记录当前递增序列的开头，一个ret记录当前最大值
简单的动态规划 ret=max(ret,i-head+1)  

**695
递归查找最大值，对每个1四向探索，查找之后将经过的点变为-1
比较当前最大值
